# **Market Service Brownfield Enhancement Architecture (修订版)**

## **Introduction**

This document outlines the architectural approach for enhancing the AegisTrader ecosystem with a new **Market Service**。 Its primary goal is to serve as the guiding architectural blueprint for AI-driven development of this new service, ensuring seamless integration with the existing AegisSDK platform。

Relationship to Existing Architecture:  
This document defines how the new Market Service components will be built upon and integrate with the existing AegisSDK framework。 It translates the provided DDD design into a formal architectural plan.

### **Existing Project Analysis**

The new Market Service will be built on the existing AegisSDK platform.

**Current Project State:**

* **Primary Purpose**: The foundation is the AegisSDK, a lightweight, high-performance Inter-Process Communication (IPC) SDK for building microservices using NATS, following Hexagonal Architecture and DDD principles。 It is complemented by aegis-sdk-dev, a toolkit for rapid project scaffolding, code generation, and deployment。  
* **Current Tech Stack**: The ecosystem is built on Python 3.13+, NATS (with JetStream and KV Store), Docker, and Kubernetes (using Helm)。  
* **Architecture Style**: The enforced architecture is Hexagonal (Ports and Adapters) and Domain-Driven Design。  
* **Deployment Method**: The standard deployment method is via containerized services orchestrated by Kubernetes。

**Available Documentation:**

* Comprehensive DDD design documents for the new Market Service (Domain Exploration, Strategic Design, Tactical Design, Architecture Patterns, and Overview).  
* Detailed documentation for the AegisSDK runtime and the AegisSDK-dev toolkit.

**Identified Constraints:**

* The Market Service must be implemented using the AegisSDK framework and its components, such as Service and SingleActiveService。  
* All inter-service communication must use NATS, following the patterns established by the SDK (RPC, Events, Commands)。  
* The project structure and DevOps automation should leverage the aegis-sdk-dev toolkit。

### **Change Log**

| Change | Date | Version | Description | Author |
| :---- | :---- | :---- | :---- | :---- |
| Initial Draft | 2025-08-11 | 1.0 | Initial architecture based on DDD design | Winston (Architect) |
| **Revision** | **2025-08-11** | **1.1** | **Updated to reflect a single-service architecture per user feedback.** | **Winston (Architect)** |

## **Enhancement Scope and Integration Strategy**

### **Enhancement Overview**

Enhancement Type: New Service Development.  
Scope: To build a multi-market real-time quote service that receives CTP (futures) and SOPT (stock options) data, validates it, publishes real-time Tick events, and stores aggregated minute-level K-lines (Bars) to a time-series database。  
Integration Impact: High. This is a new core service within the AegisTrader ecosystem.

### **Integration Approach**

Code Integration Strategy: The service will be built as a new, independent application package that depends on the aegis-sdk runtime library. It will follow the standard DDD project structure generated by aegis-sdk-dev。  
Database Integration: The service will write to a dedicated ClickHouse database for historical data and use the shared NATS KV Store for caching and real-time state。  
API Integration: The service acts as an adapter for external market data APIs (CTP, SOPT) and exposes its data to the rest of the ecosystem via NATS events and RPC calls, not a public REST/HTTP API。  
UI Integration: Not applicable. This is a backend service.

### **Compatibility Requirements**

* **Existing API Compatibility**: Must integrate with the existing NATS-based messaging schema defined in AegisSDK (RPCRequest, Event, etc.)。  
* **Database Schema Compatibility**: Will introduce new tables in ClickHouse and new key structures in NATS KV, designed not to conflict with other services。  
* **Performance Impact**: The service must meet high-performance targets, including \<1ms processing latency and \>50,000 TPS throughput, to avoid negatively impacting the trading ecosystem。

## **Tech Stack Alignment**

The enhancement will adopt the established technology stack of the Aegis platform.

| Category | Current Technology | Version | Usage in Enhancement | Notes |
| :---- | :---- | :---- | :---- | :---- |
| **Language** | Python | 3.13+ | Core implementation language | Adheres to platform standard |
| **Framework** | AegisSDK | 4.1.0 (assumed) | Service lifecycle, messaging, HA | Core runtime for all services |
| **Messaging** | NATS JetStream | 2.9+ | Events, Commands, KV Store | Central nervous system for all communication |
| **Database** | ClickHouse | Cluster | Historical data persistence | Chosen for time-series performance |
| **Cache** | NATS KV Store | \- | Real-time data, K-line cache | Unified tech stack, leverages NATS |
| **API Style** | RPC over NATS | \- | Internal service communication | AegisSDK's native communication pattern |
| **Testing** | pytest | \- | Unit and Integration Testing | Standard from aegis-sdk-dev template |
| **Deployment** | Docker / K8s / Helm | \- | Containerization and Orchestration | Standard platform deployment method |

## **Component Architecture**

The market-service will be built as a **single, unified application** that internally adheres to a logical, layered DDD architecture.

* **Domain Layer**: The core of the application. It contains the business logic, aggregates (MarketDataStream), entities, and value objects that are free from any infrastructure concerns.  
* **Application Layer**: Orchestrates the domain layer to perform application-specific tasks. It defines the use cases (e.g., "process a market tick") but does not contain business logic itself.  
* **Infrastructure Layer**: Contains the implementation details for external concerns, such as the NATS adapter for messaging, the ClickHouse repository for persistence, and adapters for the vnpy gateways.  
* **Cross-domain Layer**: Provides the Anti-Corruption Layer (ACL) to translate data from external sources (like CTP/SOPT) into the application's rich domain model, protecting the core logic from external influence.

### **Internal Logic Flow Diagram**

Code snippet

graph TD  
    subgraph External Systems  
        Exchange\[CTP/SOPT Exchange\]  
        NATS\[NATS Message Bus\]  
        ClickHouse\[ClickHouse DB\]  
    end

    subgraph "Market-Service Application"  
        subgraph "Infrastructure Layer"  
            GatewayAdapter\[Gateway Adapter\<br/\>(vnpy)\]  
            NatsPublisher\[NATS Publisher\]  
            ClickHouseRepo\[ClickHouse Repository\]  
        end

        subgraph "Cross-domain Layer"  
            ACL\[Anti-Corruption Layer\]  
        end

        subgraph "Application Layer"  
            UseCase\[Use Case Handler\<br/\>e.g., ProcessTick\]  
        end

        subgraph "Domain Layer"  
            Aggregate\[Domain Aggregate\<br/\>e.g., MarketDataStream\]  
        end  
    end

    Exchange \--\> GatewayAdapter  
    GatewayAdapter \-- Raw Data \--\> ACL  
    ACL \-- Domain Model \--\> UseCase  
    UseCase \-- Commands \--\> Aggregate  
    Aggregate \-- Domain Events \--\> UseCase  
    UseCase \-- Data to Persist \--\> ClickHouseRepo  
    UseCase \-- Events to Publish \--\> NatsPublisher  
    NatsPublisher \--\> NATS  
    ClickHouseRepo \--\> ClickHouse

## **Source Tree Integration**

The project structure will follow the standard enterprise DDD template generated by the aegis-sdk-dev toolkit, as provided in your screenshot.

Plaintext

market-service/  
├── .ruff\_cache/  
├── app\_types/          \# Shared type definitions and interfaces  
├── application/        \# Application services and use case handlers  
├── crossdomain/        \# Anti-Corruption Layer for external data  
├── domain/             \# Core business logic, aggregates, entities  
├── infra/              \# Database, messaging, gateway adapters  
├── k8s/                \# Kubernetes and Helm deployment charts  
├── pkg/                \# Business-agnostic utility packages  
├── tests/              \# Unit and integration tests  
├── .dockerignore  
├── .env.example        \# Environment variable templates  
├── .gitignore  
├── Dockerfile          \# Docker container definition  
├── main.py             \# Main application entry point  
├── Makefile            \# Automation scripts for build, test, deploy  
├── pyproject.toml      \# Project metadata and dependencies  
└── README.md

## **Infrastructure and Deployment Integration**

### **Enhancement Deployment Strategy**

**Deployment Approach**: The entire market-service application will be packaged into a **single Docker container**. This container will be deployed to Kubernetes as a Deployment or StatefulSet, managed by the Helm charts located in the k8s/ directory. High availability for the gateway logic will be handled *within* the single service by the SingleActiveService leader election pattern。

### **Rollback Strategy**

**Rollback Method**: Standard Kubernetes and Helm rollback procedures will be used.

## **Testing Strategy**

The testing strategy remains the same, focused on validating the different layers within the single application.

## **Risk Assessment and Mitigation**

The risks and mitigation strategies remain the same, as the internal logic and external dependencies have not changed.
