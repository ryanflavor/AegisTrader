# Story 3.3b: Update Monitor-API SDK Compatibility

## Status
Approved

## Story
**As a** system maintainer,
**I want** to update the monitor-api to correctly monitor the current SDK's service instances and their evolved data models,
**so that** the monitoring system accurately displays runtime state including sticky-active status, heartbeats, and failover states.

## Acceptance Criteria
1. Monitor-api successfully connects to NATS using the current SDK interfaces (NATSAdapter, NATSKVStore).
2. All unit tests pass with proper mocking of actual SDK classes.
3. Service registry operations (CRUD) work correctly with the current KV Store implementation.
4. Service instance monitoring retrieves and displays ALL evolved SDK features:
   - Basic status (ACTIVE, STANDBY, UNHEALTHY)
   - Single-active states (leader election status for SingleActiveService)
   - Heartbeat timestamps and staleness
   - Service lifecycle states (INITIALIZING, STARTING, STARTED, STOPPING, STOPPED, ERROR)
   - Metrics data (if available in metadata)
   - Failover policy configuration
   - Handler registry info (RPC methods, event subscriptions)
5. No regression in existing monitor-api functionality.

## Tasks / Subtasks
- [ ] Task 1: Audit current SDK usage in monitor-api (AC: 1)
  - [ ] Review all files importing aegis_sdk
  - [ ] Document actual SDK classes and methods being used
  - [ ] Identify mismatches between expected and actual SDK interfaces
  - [ ] Check for deprecated or removed SDK features
- [ ] Task 2: Update aegis_sdk_kv_adapter.py implementation (AC: 1, 3)
  - [ ] Fix initialization to use NATSAdapter and NATSKVStore properly
  - [ ] Update connection logic to match current SDK patterns
  - [ ] Ensure proper error handling with SDK exceptions
  - [ ] Add proper type hints for current SDK classes
  - [ ] Test connection to local K8s NATS
- [ ] Task 3: Fix all unit tests for SDK adapters (AC: 2)
  - [ ] Update test_aegis_sdk_adapter.py to mock NATSAdapter and NATSKVStore
  - [ ] Fix test_aegis_composition.py for current SDK
  - [ ] Update test_aegis_kv_adapter.py mocks
  - [ ] Ensure all mocked methods match actual SDK interface
  - [ ] Add integration tests with real SDK if missing
- [ ] Task 4: Update service instance repository adapter (AC: 4)
  - [ ] Verify ServiceInstanceRepositoryAdapter works with current KV Store
  - [ ] Update key prefix handling if needed
  - [ ] Ensure proper JSON serialization/deserialization
  - [ ] Test retrieval of service instances from registry
- [ ] Task 5: Verify end-to-end functionality (AC: 5)
  - [ ] Test monitor-api can connect to K8s NATS
  - [ ] Verify CRUD operations on service definitions
  - [ ] Confirm service instance monitoring works
  - [ ] Check API endpoints return correct data
  - [ ] Run full integration test suite
- [ ] Task 6: Update documentation and examples (AC: 5)
  - [ ] Document any API changes in monitor-api
  - [ ] Update README if setup process changed
  - [ ] Add migration notes for SDK interface changes
  - [ ] Create example of proper SDK usage pattern

## Dev Notes

### Previous Story Insights
From Story 3.3 (Automatic Failover):
- SDK uses NATSAdapter and NATSKVStore, not a monolithic AegisSDK class
- NATSKVStore provides methods: connect, disconnect, get, put, delete, keys, watch, etc.
- SDK follows hexagonal architecture with ports and adapters pattern
- Services register with sticky-active status for failover patterns

From Story 2.1 (Original Monitor Design):
- Monitor-api manages ServiceDefinitions (static config)
- Also needs to monitor ServiceInstances (runtime state)
- Two different data models and purposes

From Story 3.4 draft:
- Need monitor-api as reference implementation for external SDK clients
- Current K8s environment has NATS running at localhost:4222 (port-forwarded)
- Monitor-api is deployed but may have issues with SDK compatibility

### What Monitor-API Needs to Monitor from Current SDK

Monitor-api has TWO distinct responsibilities:

1. **Manage ServiceDefinitions** (Static Configuration - Story 2.1):
   - CRUD operations on allowed services
   - Stored under custom keys in KV Store
   - Fields: serviceName, owner, description, version, createdAt, updatedAt

2. **Monitor ServiceInstances** (Runtime State - Current SDK):
   - Read-only observation of running services
   - Stored by SDK under pattern: `service-instances.{service_name}.{instance_id}`
   - Fields from current SDK's ServiceInstance model:
     ```python
     service_name: str           # Name of the service
     instance_id: str           # Unique instance identifier
     version: str               # Service version (semantic)
     status: str                # ACTIVE, UNHEALTHY, STANDBY
     last_heartbeat: datetime   # Last heartbeat timestamp
     sticky_active_group: str   # For SingleActiveService pattern (group identifier)
     sticky_active_status: str  # Leader status: ACTIVE, STANDBY, ELECTING (when using SingleActiveService)
     metadata: dict            # Additional service metadata
     ```

### Current SDK Structure and Best Practices

**IMPORTANT**: Monitor-api is an EXTERNAL CLIENT that observes services, NOT a service itself. It should:
1. Use SDK's infrastructure components directly (NATSAdapter, NATSKVStore)
2. NOT inherit from Service or SingleActiveService classes
3. Access the KV Store to read/write service definitions and monitor instances
4. Act as a management plane, not a data plane service

Based on SDK documentation [Source: sdk-service-types.md]:
```python
# Correct pattern for external clients (like monitor-api)
from aegis_sdk.infrastructure.nats_adapter import NATSAdapter
from aegis_sdk.infrastructure.nats_kv_store import NATSKVStore

# Initialize NATS connection (as infrastructure client, not service)
nats_adapter = NATSAdapter(pool_size=1, use_msgpack=False)
await nats_adapter.connect(["nats://localhost:4222"])

# Initialize KV Store for direct access
kv_store = NATSKVStore(nats_adapter)
await kv_store.connect("service_registry")  # Access the registry directly

# Available methods on NATSKVStore for monitoring:
# - get(key): Get a service definition or instance
# - put(key, value): Store/update service definitions
# - delete(key): Remove service definitions
# - keys(): List all registered services
# - watch(key): Monitor for changes
# - exists(key): Check if service exists
```

This is different from services that USE the SDK to become part of the system:
```python
# Pattern for actual services (NOT monitor-api)
from aegis_sdk.application.service import Service

service = Service("my-service", message_bus, ...)
await service.start()  # Registers itself, handles RPC, etc.
```

### How to Access Extended Service Data

**Important Note:** The "sticky" behavior is achieved through client-side retry configuration, not a separate service type. SingleActiveService provides leader election, and clients implement stickiness through retry policies.

Monitor-api needs to retrieve service instances from KV Store and parse the metadata field:

```python
# Read service instance from KV Store
key = "service-instances.order-processor.abc123"
entry = await kv_store.get(key)
instance_data = json.loads(entry.value)

# Parse extended metadata
instance = ServiceInstance(**instance_data)
metadata = instance.metadata  # Dict containing all extended info

# Extract specific features
metrics = metadata.get("metrics", {})
handlers = metadata.get("handlers", {})
failover_policy = metadata.get("failover_policy", {})
lifecycle_state = metadata.get("lifecycle_state", "UNKNOWN")

# Display enriched information in UI
```

**Important**: Services built with current SDK store this extended data in the metadata field. Monitor-api must:
1. Parse the metadata field correctly
2. Handle missing fields gracefully (older services may not have all fields)
3. Display meaningful defaults when data is unavailable
4. Update UI to show these new fields

### Files Requiring Updates
Monitor-api files using SDK [Source: grep analysis]:
1. `/apps/monitor-api/app/infrastructure/aegis_sdk_kv_adapter.py`
   - Currently imports: NATSAdapter, NATSKVStore, KVOptions
   - Needs: Proper initialization and connection handling

2. `/apps/monitor-api/app/infrastructure/aegis_kv_composition.py`
   - Currently imports: NATSAdapter
   - Needs: Review for compatibility

3. `/apps/monitor-api/tests/mocks.py`
   - Currently imports: KVStorePort from aegis_sdk.ports.kv_store
   - Needs: Verify port interface still exists

4. Test files needing updates:
   - `tests/unit/test_aegis_sdk_adapter.py` - Mocking wrong class (AegisSDK)
   - `tests/unit/test_aegis_composition.py` - May have similar issues
   - `tests/infrastructure/test_aegis_kv_adapter.py` - Needs verification

### API Specifications
Current monitor-api endpoints that depend on SDK:
- `GET /api/services` - List service definitions (uses KV Store)
- `POST /api/services` - Create service definition
- `PUT /api/services/{id}` - Update service definition
- `DELETE /api/services/{id}` - Delete service definition
- `GET /api/instances` - List service instances from registry
- `GET /api/metrics` - Get service metrics

These must continue working after SDK updates.

### Testing Requirements
Testing approach [Source: architecture/testing-strategy.md]:
- Use pytest with @pytest.mark.asyncio for async tests
- Mock SDK classes properly in unit tests
- Use real NATS connection for integration tests
- Test with local K8s environment (localhost:4222)

Critical test scenarios:
- test_adapter_connects_to_nats
- test_kv_store_crud_operations
- test_service_registry_operations
- test_instance_repository_retrieval
- test_error_handling_on_connection_failure

### Technical Constraints
- Must maintain backward compatibility with monitor-ui
- Cannot change API response formats
- Must work with existing K8s NATS deployment
- Should follow hexagonal architecture pattern
- Use dependency injection for testability

### Migration Strategy
1. **Minimal Changes First**: Only fix what's broken
2. **Preserve API Contract**: Don't change external interfaces
3. **Test Incrementally**: Fix and test one adapter at a time
4. **Maintain Compatibility**: Ensure monitor-ui still works
5. **Document Changes**: Note any behavioral differences

### Key Implementation Considerations
- **Separation of Concerns**: Monitor-api is a management plane tool, NOT a data plane service
- **Direct KV Access**: Use NATSKVStore directly to read/write service registry data
- **No Service Registration**: Monitor-api should NOT register itself as a service
- **Error Handling**: SDK exceptions may have changed - need proper translation
- **Connection Management**: Ensure proper cleanup on disconnect
- **Type Safety**: Update type hints to match current SDK
- **Performance**: Verify no performance regression with new SDK
- **Logging**: Maintain comprehensive logging for debugging

### Architecture Clarification
Monitor-api's role in the system:
```
┌─────────────────────────────────────────────┐
│           Management Plane                   │
│  ┌─────────────┐        ┌──────────────┐   │
│  │ Monitor-API │────────│  Monitor-UI  │   │
│  └──────┬──────┘        └──────────────┘   │
│         │                                    │
│         │ Direct KV Store Access             │
│         │ (Read/Write/Watch)                 │
│         ▼                                    │
│  ┌─────────────────────────────────────┐   │
│  │    NATS KV Store (Registry)         │   │
│  └─────────────────────────────────────┘   │
└─────────────────────────────────────────────┘
           ▲
           │ Service Registration
           │ (via SDK Service classes)
┌─────────────────────────────────────────────┐
│           Data Plane                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐ │
│  │ Service A│  │ Service B│  │ Service C│ │
│  │ (SDK)    │  │ (SDK)    │  │ (SDK)    │ │
│  └──────────┘  └──────────┘  └──────────┘ │
└─────────────────────────────────────────────┘
```

### Missing SDK Features That Monitor-API Must Track

After reviewing sdk-service-types.md, the following features need to be tracked:

1. **Extended Metadata Fields** (stored in ServiceInstance.metadata):
   - **Metrics**: Request counts, latency percentiles (p50, p90, p99), error rates
   - **Handlers**: List of RPC methods, event subscriptions, command handlers
   - **Configuration**: Retry policy, failover policy, selection strategy preference
   - **Resources**: Connection pool size, active connections, queue depths
   - **Dependencies**: Services this instance calls, dependency health

2. **Service Lifecycle States** (beyond basic status):
   ```python
   # From SDK's ServiceLifecycleState enum
   INITIALIZING = "initializing"  # Service is being constructed
   STARTING = "starting"          # Service is starting up
   STARTED = "started"            # Service is fully operational
   STOPPING = "stopping"          # Service is shutting down
   STOPPED = "stopped"            # Service has stopped
   ERROR = "error"                # Service encountered fatal error
   ```

3. **Failover Policy Details** (for SingleActiveService with client-side sticky behavior):
   ```python
   failover_policy: {
       "mode": "aggressive|balanced|conservative",
       "detection_threshold_ms": 500,    # Time to detect failure
       "election_delay_ms": 100,         # Delay before election
       "max_election_time_ms": 1000,     # Max time for election
       "enable_pre_election": true        # Pre-election optimization
   }
   ```

4. **Service Discovery Configuration**:
   ```python
   discovery_config: {
       "type": "basic|cached|watchable",
       "cache_ttl": 30,                  # For cached discovery
       "watch_enabled": true,             # For watchable discovery
       "reconnect_attempts": 10          # Watch reconnection attempts
   }
   ```

5. **Handler Registry Information**:
   ```python
   handlers: {
       "rpc_methods": ["get_order", "process_payment"],
       "event_patterns": ["orders.*", "payments.*"],
       "command_handlers": ["execute_trade"],
       "subscription_modes": {
           "orders.*": "COMPETE",
           "payments.*": "BROADCAST"
       }
   }
   ```

### How Monitor-API Should Display SDK Service States

The monitor UI needs to show the evolved service states clearly:

1. **Basic Service Status**:
   - 🟢 ACTIVE: Service is healthy and processing requests
   - 🟡 STANDBY: Service is ready but not processing (for sticky-active)
   - 🔴 UNHEALTHY: Service failed health checks
   - ⚫ MISSING: No heartbeat for > TTL (service is dead)

2. **Single-Active Pattern Status** (when sticky_active_group is present - indicates SingleActiveService):
   - 👑 ACTIVE: This instance is the leader for its group
   - ⏳ STANDBY: Waiting to become leader if needed
   - 🔄 ELECTING: Currently in leader election process
   - Group display: Show all instances in same sticky_active_group together

3. **Heartbeat Health**:
   - Show time since last heartbeat
   - Mark as "stale" if heartbeat > 5 seconds old
   - Mark as "dead" if heartbeat > TTL

4. **Instance Grouping**:
   ```
   Service: order-processor
   ├── Group: production (single-active with leader election)
   │   ├── order-processor-abc123 [👑 ACTIVE] ♥ 1s ago
   │   ├── order-processor-def456 [⏳ STANDBY] ♥ 2s ago
   │   └── order-processor-ghi789 [⏳ STANDBY] ♥ 1s ago
   └── Standalone instances
       └── order-processor-xyz999 [🟢 ACTIVE] ♥ 3s ago
   ```

### Integration with Existing Code
Current broken pattern in tests:
```python
# WRONG - AegisSDK doesn't exist
with patch("app.infrastructure.aegis_sdk_kv_adapter.AegisSDK", return_value=mock_sdk):
    await adapter.connect("nats://localhost:4222")
```

Should be:
```python
# CORRECT - Mock actual SDK classes
with patch("app.infrastructure.aegis_sdk_kv_adapter.NATSAdapter") as mock_nats:
    with patch("app.infrastructure.aegis_sdk_kv_adapter.NATSKVStore") as mock_kv:
        mock_nats_instance = AsyncMock()
        mock_nats.return_value = mock_nats_instance
        mock_kv_instance = AsyncMock()
        mock_kv.return_value = mock_kv_instance
        
        await adapter.connect("nats://localhost:4222")
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation for SDK compatibility update | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be filled by developer]

### Debug Log References
[To be filled during implementation]

### Completion Notes
[To be filled during implementation]

### File List
[To be filled during implementation]

## QA Results
[To be filled by QA]