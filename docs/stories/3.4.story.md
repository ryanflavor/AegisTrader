# Story 3.4: SDK Developer Experience and Testing Tools

## Status
Draft

## Story
**As a** developer using the AegisSDK,
**I want** user-friendly configuration helpers and ready-to-use test examples that work with my local K8s environment,
**so that** I can quickly understand and test client-service interactions without dealing with complex setup.

## Acceptance Criteria
1. Developers can connect to the existing K8s NATS cluster (aegis-trader namespace) with minimal configuration.
2. A set of example client and service implementations demonstrate common patterns (RPC, events, sticky-active).
3. Helper utilities automatically discover NATS connection details from K8s and configure the SDK.
4. Clear quickstart guide shows how to run examples against the local K8s environment in under 5 minutes.
5. Test scenarios include service discovery, failover, and message patterns with observable output.

## Tasks / Subtasks
- [ ] Task 1: Create K8s-aware configuration helper (AC: 1, 3)
  - [ ] Implement auto-discovery of NATS endpoint from K8s service
  - [ ] Create environment detection (local K8s vs Docker vs cloud)
  - [ ] Build connection string generator for different environments
  - [ ] Add retry logic for K8s port-forwarding scenarios
  - [ ] Write unit tests for configuration helpers
- [ ] Task 2: Build example service implementations (AC: 2, 5)
  - [ ] Create EchoService with base Service (shows load balancing with multiple instances)
  - [ ] Create EchoSingleService with SingleActiveService (shows failover behavior)
  - [ ] Implement order processing service with sticky-active pattern
  - [ ] Build event publisher/subscriber example
  - [ ] Add metric collection service example with metadata enrichment
  - [ ] Create example showing difference between Service vs External Client patterns
  - [ ] Include comprehensive logging showing which instance handles each request
- [ ] Task 3: Develop example client applications (AC: 2, 5)
  - [ ] Create interactive CLI client for testing RPC calls
  - [ ] Build event stream monitor client
  - [ ] Implement service discovery explorer
  - [ ] Add failover testing client with timing metrics
  - [ ] Create load testing client for performance validation
- [ ] Task 4: Implement developer utilities (AC: 3, 4)
  - [ ] Create `aegis-quickstart` CLI tool for project scaffolding
  - [ ] Build `aegis-test` runner for automated scenario testing
  - [ ] Add `aegis-monitor` for real-time service observation
  - [ ] Implement configuration validator and troubleshooter
  - [ ] Write shell scripts for common K8s operations
- [ ] Task 5: Create comprehensive quickstart documentation (AC: 4)
  - [ ] Write step-by-step setup guide for local K8s testing
  - [ ] Document each example with expected output
  - [ ] Add troubleshooting section for common issues
  - [ ] Include architecture diagrams showing message flow
  - [ ] Create video walkthrough or animated terminal recordings
- [ ] Task 6: Add integration tests for K8s environment (AC: 1, 5)
  - [ ] Test automatic NATS discovery from K8s services
  - [ ] Verify examples work with port-forwarding
  - [ ] Test failover scenarios in K8s pods
  - [ ] Validate service registration persistence
  - [ ] Ensure cleanup of test resources

## Dev Notes

### Previous Story Insights
From Story 3.3 (Automatic Failover):
- K8s integration tests successfully connect to localhost:4222 (port-forwarded NATS)
- SingleActiveService with FailoverPolicy working in K8s environment
- Sub-2-second failover achieved in K8s tests (1.06 seconds)
- NATS KV Store used for service registry and leader election

From Story 3.3b (Monitor-API SDK Compatibility):
- Monitor-api is an EXTERNAL CLIENT, not a service itself
- Clear distinction between management plane (monitor-api) and data plane (services)
- SDK provides infrastructure components for both patterns
- Extended metadata fields available in ServiceInstance for observability

From existing K8s deployment (verified):
- NATS StatefulSet: `aegis-trader-nats-0` (2/2 containers ready)
- Monitor API: `aegis-trader-monitor-api` on port 8100
- Monitor UI: `aegis-trader-monitor-ui` on port 3100
- NATS box for debugging: `aegis-trader-nats-box`
- Services exposed: `aegis-trader-nats` (ClusterIP on port 4222)

### Data Models
Configuration models needed [Source: architecture/data-models-schema-design.md]:
```python
class SDKConfig(BaseModel):
    """Simplified SDK configuration for developers."""
    service_name: str = Field(..., description="Your service name")
    nats_url: str = Field(default="auto", description="NATS URL or 'auto' for K8s discovery")
    environment: Literal["local-k8s", "docker", "production"] = Field(default="local-k8s")
    debug: bool = Field(default=True, description="Enable debug logging")
    
class K8sNATSConfig(BaseModel):
    """K8s-specific NATS configuration."""
    namespace: str = Field(default="aegis-trader")
    service_name: str = Field(default="aegis-trader-nats")
    port: int = Field(default=4222)
    use_port_forward: bool = Field(default=True)
```

### API Specifications
K8s Service Discovery [Verified from actual K8s cluster]:
- K8s Service Name: `aegis-trader-nats` 
- K8s Namespace: `aegis-trader`
- Service Port: `4222/TCP` (named "nats")
- In-cluster URL: `aegis-trader-nats.aegis-trader.svc.cluster.local:4222`
- Port-forward command: `kubectl port-forward -n aegis-trader svc/aegis-trader-nats 4222:4222`
- Local access URL: `nats://localhost:4222` (after port-forwarding)
- NATS Config: JetStream enabled with 1Gi file store

Helper utilities API:
```python
# Auto-configuration helper
async def create_service(name: str, **kwargs) -> Service:
    """Create a service with automatic K8s configuration."""
    config = await discover_k8s_config()
    return Service(name, config, **kwargs)

# Test runner
async def run_test_scenario(scenario: str) -> TestResults:
    """Run predefined test scenarios against K8s environment."""
    pass
```

### Component Specifications
Following DDD architecture [Source: architecture/ddd_v2.md]:

**Application Layer** (Developer Tools):
- QuickstartGenerator: Scaffolds new SDK projects
- ConfigurationHelper: Auto-discovers and validates config
- TestScenarioRunner: Executes test scenarios
- ServiceExplorer: Interactive service discovery tool
- PatternSelector: Helps choose between Service vs External Client pattern

**Infrastructure Layer** (K8s Integration):
- K8sServiceDiscovery: Discovers NATS from K8s API
- PortForwardManager: Manages kubectl port-forwarding
- K8sConfigLoader: Loads kubeconfig and context

**Example Services** (Data Plane - using Service classes):

1. **RPC Pattern Examples**:
   - `EchoService` (Base Service + RPC): 
     * Pattern: Multiple active instances, load-balanced RPC
     * Use case: Stateless request/response, horizontal scaling
     * Client calls → SDK picks one instance → Returns response
   
   - `EchoSingleService` (SingleActiveService + RPC):
     * Pattern: Single active instance, exclusive RPC processing
     * Use case: Testing failover, ordered processing, debugging
     * Client calls → Only leader responds → Failover on leader death

2. **Event Pattern Examples**:
   - `EventPublisher` (Base Service + Event Publishing):
     * Pattern: Any instance can publish events
     * Use case: Generating events from multiple sources
     * Publishes to topics like "orders.created", "payments.processed"
   
   - `EventSubscriber` (Base Service + Event Subscription):
     * Pattern: Multiple subscription modes
     * COMPETE mode: Only one instance processes each event (load balanced)
     * BROADCAST mode: All instances receive all events
     * EXCLUSIVE mode: Only one specific instance receives events

3. **Stateful Service Examples**:
   - `OrderProcessor` (SingleActiveService + State Management):
     * Pattern: Sticky-active with leader election
     * Use case: Order processing requiring consistency
     * Maintains order state, ensures exactly-once processing
   
   - `InventoryManager` (SingleActiveService + Resource Control):
     * Pattern: Single writer for shared resource
     * Use case: Managing limited resources, preventing conflicts
     * Only leader can modify inventory counts

4. **Observability Examples**:
   - `MetricsCollector` (Base Service + Metadata Enrichment):
     * Pattern: Enriches ServiceInstance.metadata with metrics
     * Use case: Collecting and exposing service metrics
     * Adds performance data to metadata for monitoring
   
   - `HealthReporter` (Base Service + Health Checks):
     * Pattern: Custom health check implementation
     * Use case: Complex health validation beyond heartbeats
     * Reports detailed health status to registry

**Example Tools** (Management Plane - using infrastructure directly):
- ServiceInspector: External tool to read service instances (like monitor-api)
- MetricsAggregator: External tool to collect metrics from metadata
- HealthChecker: External tool to monitor service heartbeats

### File Locations
Based on project structure [Source: architecture/source-tree.md]:
```
/packages/aegis-sdk/
├── aegis_sdk/
│   ├── developer/                    # New: Developer experience tools
│   │   ├── __init__.py
│   │   ├── config_helper.py         # Auto-configuration utilities
│   │   ├── k8s_discovery.py        # K8s NATS discovery
│   │   ├── quickstart.py           # Project scaffolding
│   │   └── test_runner.py          # Scenario test runner
│   └── examples/                    # Enhanced examples
│       ├── quickstart/              # New: Quickstart examples
│       │   ├── echo_service.py
│       │   ├── echo_client.py
│       │   ├── event_demo.py
│       │   └── README.md
│       ├── advanced/                # New: Advanced patterns
│       │   ├── order_service.py
│       │   ├── metrics_collector.py
│       │   └── failover_tester.py
│       ├── management/              # New: Management plane examples
│       │   ├── service_inspector.py # Like monitor-api pattern
│       │   ├── metrics_reader.py    # Read metadata from instances
│       │   └── health_monitor.py    # External health monitoring
│       └── k8s/                     # New: K8s-specific examples
│           ├── deploy_service.yaml
│           ├── test_in_cluster.py
│           └── port_forward_test.py
├── scripts/                         # New: Helper scripts
│   ├── setup_k8s_dev.sh           # Setup local K8s environment
│   ├── run_examples.sh            # Run all examples
│   └── test_failover.sh           # Test failover scenarios
├── docs/                           # New: Developer documentation
│   ├── quickstart.md              # 5-minute quickstart guide
│   ├── examples.md                # Example walkthroughs
│   └── troubleshooting.md         # Common issues and solutions
└── tests/
    └── integration/
        └── test_k8s_examples.py    # Test all examples work
```

### Technical Constraints
Requirements [Source: architecture/coding-standards.md & tech-stack.md]:
- Python 3.13+ with full type annotations
- All examples must work with existing K8s deployment
- No modifications to existing NATS cluster configuration
- Examples must handle port-forwarding transparently
- Clear console output for learning/debugging
- Follow existing SDK patterns (DDD, hexagonal architecture)

K8s Environment Constraints (verified from cluster):
- Namespace: `aegis-trader`
- NATS service: `aegis-trader-nats` (ClusterIP)
- NATS port: `4222` (TCP)
- Existing pods: aegis-trader-nats-0, monitor-api, monitor-ui, nats-box
- Port forwarding already active on localhost:4222
- Support both in-cluster and port-forwarded access
- Handle kubectl context switching gracefully

### Testing Requirements
Testing approach [Source: architecture/testing-strategy.md]:
- All examples must have accompanying tests
- Tests must work with port-forwarded NATS
- Use pytest with @pytest.mark.asyncio
- Test both success and failure scenarios
- Validate against real K8s environment

Test scenarios to implement:
- test_auto_discovery_finds_nats_service
- test_examples_run_successfully
- test_failover_visible_in_output
- test_service_discovery_shows_all_services
- test_quickstart_under_five_minutes
- test_works_with_port_forwarding

### Integration with Existing Code
Current SDK usage pattern (complex):
```python
# Current complex setup
nats = NATSAdapter()
await nats.connect("nats://localhost:4222")
kv_store = NATSKVStore(nats)
await kv_store.connect("service_registry")
registry = KVServiceRegistry(kv_store)
discovery = BasicServiceDiscovery(registry)
service = Service("my-service", nats, registry, discovery, ...)
```

New simplified pattern (developer-friendly):
```python
# New simple setup
from aegis_sdk.developer import quick_setup

service = await quick_setup("my-service")
# Auto-discovers K8s NATS, configures everything

@service.rpc("echo")
async def echo(params):
    return {"echo": params}

await service.start()
```

### Key Implementation Considerations
- **Zero Configuration Goal**: Developers shouldn't need to know NATS URLs or K8s details
- **Progressive Disclosure**: Simple examples first, advanced patterns later
- **Observable Behavior**: All examples should have clear, visible output
- **Fail-Fast**: Clear error messages when K8s/NATS not available
- **Interactive Mode**: CLI tools should support interactive exploration
- **Documentation First**: Write docs alongside code for better learning
- **Two Usage Patterns**: Clearly distinguish between:
  1. Building services that participate in the system (use Service/SingleActiveService)
  2. Building tools that observe/manage the system (use infrastructure components directly)
- **Metadata Enrichment**: Show how to add observability data to ServiceInstance.metadata
- **Monitor-API as Reference**: Use monitor-api as example of external client pattern

### Developer Experience Principles
- **Convention over Configuration**: Sensible defaults for everything
- **Fast Feedback Loop**: See results immediately
- **Learning by Doing**: Interactive examples over static docs
- **Real Environment**: Test against actual K8s, not mocks
- **Progressive Complexity**: Start simple, add complexity gradually
- **Clear Pattern Demonstration**: Each example should clearly show:
  - When to use base Service (stateless, load-balanced)
  - When to use SingleActiveService (stateful, ordered, single-processor)
  - When to build external tools (management, monitoring)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation for developer experience | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
[To be filled by developer]

### Debug Log References
[To be filled during implementation]

### Completion Notes
[To be filled during implementation]

### File List
[To be filled during implementation]

## QA Results
[To be filled by QA]